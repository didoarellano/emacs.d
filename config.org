#+TITLE: Dido's Emacs Configuration

* Package management

Initialize ~package.el~ and use the melpa repositories.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
#+END_SRC

Make sure [[https://github.com/jwiegley/use-package][use-package]] is installed.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

* Backup and temp files

Try to keep emacs from pooping all over my home directory with backups, save-files, ido, smex, etc.

Set the temp directory.

#+BEGIN_SRC emacs-lisp
  (defvar --tmp-directory (expand-file-name (concat user-emacs-directory "tmp/")))
  (setq backup-directory-alist `(("." . ,--tmp-directory)))
  (setq auto-save-file-name-transforms `((".*" ,--tmp-directory t)))
#+END_SRC

Make backup files (even with version control); Don't create lock and autosave files.

#+BEGIN_SRC emacs-lisp
  (setq vc-make-backup-files t)
  (setq create-lockfiles nil)
  (setq auto-save-default nil)
#+END_SRC

* Evil
** evil-leader

~evil-leader~ needs to load before ~evil~ itself so that it works on ~*scratch*~ and ~*Messages*~ buffers. See the [[https://github.com/cofi/evil-leader#usage][usage section on the evil-leader README]] and [[https://github.com/cofi/evil-leader/issues/10#issuecomment-19165722][@cofi's comment]].

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :ensure t
    :init
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>"))
#+END_SRC

** evil-mode
*** Install goto-chg dependency

Install evil's ~goto-chg~ dependency from melpa "bleeding-edge" as the right version (1.6) is not in stable.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :ensure t
    :pin melpa)
#+END_SRC

*** Minimize evil state noise

Removes ~evil~ state noise in the echo area and the angle brackets from state tags in the modeline, i.e "~<N>~".

#+BEGIN_SRC emacs-lisp
  (defun --minimal-evil-states()
    (setq evil-echo-state nil)
    (setq evil-normal-state-tag   "N"
          evil-insert-state-tag   "I"
          evil-visual-state-tag   "V"
          evil-motion-state-tag   "M"
          evil-emacs-state-tag    "E"
          evil-replace-state-tag  "R"
          evil-operator-state-tag "O"))
#+END_SRC

*** Key bindings
**** ~C-e~ and ~C-y~ scrolling in bigger increments

#+BEGIN_SRC emacs-lisp
  (defun --evil-scroll-line-down ()
    (interactive)
    (evil-scroll-line-down 5))

  (defun --evil-scroll-line-up ()
    (interactive)
    (evil-scroll-line-up 5))

  (defun --bind-keys-bigger-scroll-increments ()
    (define-key evil-motion-state-map (kbd "C-e") '--evil-scroll-line-down)
    (define-key evil-motion-state-map (kbd "C-y") '--evil-scroll-line-up))
#+END_SRC

**** Insert newlines above and below current line in *Normal* state

#+BEGIN_SRC emacs-lisp
  (defun --insert-newline-below ()
    (interactive)
    (save-excursion
      (end-of-line)
      (newline)))

  (defun --insert-newline-above ()
    (interactive)
    (save-excursion
      (beginning-of-line)
      (newline)))

  (defun --bind-keys-insert-newlines ()
    (define-key evil-normal-state-map (kbd "<return>") '--insert-newline-below)
    (define-key evil-normal-state-map (kbd "<S-return>") '--insert-newline-above))
#+END_SRC

**** Case twiddling

From http://lists.gnu.org/archive/html/help-gnu-emacs/2008-10/msg00677.html

#+BEGIN_SRC emacs-lisp
  (defun --toggle-letter-case ()
    "Toggle the letter case of current word or text selection. Toggles from 3
      cases: upper case, lower case, title case, in that cyclic order."
    (interactive)
    (let (pos1 pos2 (deactivate-mark nil) (case-fold-search nil))
      (if (and transient-mark-mode mark-active)
          (setq pos1 (region-beginning)
                pos2 (region-end))
        (setq pos1 (car (bounds-of-thing-at-point 'word))
              pos2 (cdr (bounds-of-thing-at-point 'word))))

      (when (not (eq last-command this-command))
        (save-excursion
          (goto-char pos1)
          (cond
           ((looking-at "[[:lower:]][[:lower:]]") (put this-command 'state "all lower"))
           ((looking-at "[[:upper:]][[:upper:]]") (put this-command 'state "all caps"))
           ((looking-at "[[:upper:]][[:lower:]]") (put this-command 'state "init caps"))
           (t (put this-command 'state "all lower")))))

      (cond
       ((string= "all lower" (get this-command 'state))
        (upcase-initials-region pos1 pos2) (put this-command 'state "init caps"))
       ((string= "init caps" (get this-command 'state))
        (upcase-region pos1 pos2) (put this-command 'state "all caps"))
       ((string= "all caps" (get this-command 'state))
        (downcase-region pos1 pos2) (put this-command 'state "all lower")))))

  (defun --bind-keys-toggle-letter-case ()
    (define-key evil-visual-state-map "~" '--toggle-letter-case))
#+END_SRC

**** Readline bindings in *Insert* state

Apart from ~C-h~, everything is default in non-Evil Emacs.

#+BEGIN_SRC emacs-lisp
  (defun --insert-state-readline-keys ()
    (define-key evil-insert-state-map (kbd "C-a") 'move-beginning-of-line) ; was evil-paste-last-insertion
    (define-key evil-insert-state-map (kbd "C-e") 'move-end-of-line) ; was evil-copy-from-below
    (define-key evil-insert-state-map (kbd "C-h") 'backward-delete-char) ; was help character
    (define-key evil-insert-state-map (kbd "C-d") 'delete-forward-char) ; was evil-shift-left-line
    (define-key evil-insert-state-map (kbd "C-k") 'kill-line) ; was evil-insert-digraph
    (define-key evil-insert-state-map (kbd "C-y") 'yank) ; was evil-copy-from-above
    )
#+END_SRC

*** Install

Finally install and configure ~evil-mode~.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :init
    (--minimal-evil-states)
    (--bind-keys-bigger-scroll-increments)
    (--bind-keys-insert-newlines)
    (--bind-keys-toggle-letter-case)
    (--insert-state-readline-keys)
    :config
    (evil-mode 1))
#+END_SRC

** evil-surround

Flip ~s~ and ~S~ in *Visual* state. They're way too ingrained in muscle memory to ever change. Relevant: [[https://github.com/timcharper/evil-surround/pull/48][evil-surround]] and [[https://github.com/tpope/vim-surround/commit/6f0984a][vim-surround]]

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :ensure t
    :init
    (global-evil-surround-mode 1)
    (evil-define-key 'visual evil-surround-mode-map "S" 'evil-substitute)
    (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region))
#+END_SRC

** evil-matchit
*** Fix % not jumping to proper pair in visual state

#+BEGIN_SRC emacs-lisp
  (defun evilmi-customize-keybinding ()
    (evil-define-key 'visual evil-matchit-mode-map "%" '--evilmi-fix-jump-items-in-visual-mode))

  (defun --evilmi-fix-jump-items-in-visual-mode ()
    (interactive)
    (let ((visual-type (evil-visual-type)))
      (evil-exit-visual-state)
      (evil-set-marker ?\&)
      (evilmi-jump-items)
      (evil-visual-make-selection (evil-get-marker ?\&) (point) visual-type)))
#+END_SRC

*** Install

#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :ensure t
    :init (global-evil-matchit-mode 1))
#+END_SRC

** evil-numbers

#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :ensure t
    :init
    (define-key evil-normal-state-map (kbd "+") 'evil-numbers/inc-at-pt) ; was evil-previous-line-first-non-blank
    (define-key evil-normal-state-map (kbd "-") 'evil-numbers/dec-at-pt) ; was evil-next-line-first-non-blank
    )
#+END_SRC

** Modes and initial states

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'package-menu-mode 'motion)
  (evil-set-initial-state 'Custom-mode 'motion)
#+END_SRC

* GUI
** Remove all the chrome

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  (add-to-list 'default-frame-alist '(vertical-scroll-bars . nil) t)
#+END_SRC

** Fringes

Remove the right fringe and its ~$~ symbol when the line is truncated. Change the left fringe's left-curly-arrow to an ellipsis-ish

#+BEGIN_SRC emacs-lisp
  (fringe-mode `(8 . 0))
  (set-display-table-slot standard-display-table 0 ?\ )
  (define-fringe-bitmap 'left-curly-arrow
    [#b00000000
     #b00000000
     #b00000000
     #b00000000
     #b00000000
     #b00000000
     #b00000000
     #b10010010])
#+END_SRC

** Line numbers

Turn on ~linum-mode~ globally.

#+BEGIN_SRC emacs-lisp
  (global-linum-mode 1)
  (setq linum-format " %3d")
#+END_SRC

De-emphasize the line numbers.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'linum nil :height 72 :slant 'italic :weight 'semi-light)
#+END_SRC

** Themes
*** Install themes

#+BEGIN_SRC emacs-lisp
  (use-package tango-2-theme
    :ensure t
    :defer t
    :pin melpa)

  (use-package ujelly-theme
    :ensure t
    :defer t)

  (use-package leuven-theme
    :ensure t
    :defer t
    :pin melpa)
#+END_SRC

*** Configure and activate theme

Tweak the built-in adwaita light theme.

#+BEGIN_SRC emacs-lisp
  (defun --light-theme ()
    (load-theme 'adwaita t)
    (custom-set-faces
     '(default ((t (:background "#ffffff"))))
     '(fringe  ((t (:background "#ffffff"  :foreground "#888a85"))))
     '(highlight  ((t (:foreground nil :background "#eeeeee"))))
     '(cursor  ((t (:foreground nil :background "#474747"))))
     '(secondary-selection ((t (:background "#fffacd")))))
    (defface --background
      '((t (:background "#ffffff"))) ""))
#+END_SRC

Tweak the the tango-2 dark theme.

#+BEGIN_SRC emacs-lisp
  (defun --dark-theme ()
    (interactive)
    (load-theme 'tango-2 t)
    (custom-set-faces
     '(default ((t (:background "#000000"))))
     '(fringe  ((t (:background "#000000")))))
    (defface --background
      '((t (:background "#000000"))) ""))
#+END_SRC

Use the light theme.

#+BEGIN_SRC emacs-lisp
  (--light-theme)
#+END_SRC

** Powerline modeline
*** Helpers

**** Map evil states to colors.

#+BEGIN_SRC emacs-lisp
  (defun --powerline-get-evil-state-color (state is-active-window)
    (let ((reds `("I" "E" "R"))
          (greens `("V" "O"))
          (blues `("N" "M")))
      (cond
       ((and is-active-window (member state blues)) '--powerline-face-blue)
       ((member state reds) '--powerline-face-red)
       ((member state greens) '--powerline-face-green)
       (t '--powerline-face-inactive))))
#+END_SRC

**** Git branch name

Keep track of the project's current git branch name by shelling out. Other ways (~vc-mode~) of getting the branch name only work when the file is already being tracked by git.

#+BEGIN_SRC emacs-lisp
  (defvar --git-branch-name "")
  (defun --get-git-branch-name (&optional frame)
    (interactive)
    (let ((branch "")
          (shell-output (substring (shell-command-to-string "git rev-parse --abbrev-ref HEAD &") 0 -1)))
      (when (not (string-match "fatal:" shell-output))
        (setq branch shell-output))
      (setq-local --git-branch-name branch)))

  ;; TODO Add magit branch-related hooks
  (add-hook 'focus-in-hook '--get-git-branch-name)
  (add-hook 'after-make-frame-functions '--get-git-branch-name)
#+END_SRC

*** Components
**** Buffer name

#+BEGIN_SRC emacs-lisp
  (defun --powerline-buffer-id (this-face next-face)
    (list
     (powerline-buffer-id this-face 'l)
     (powerline-raw " " this-face)
     (powerline-arrow-left this-face next-face)))
#+END_SRC

**** Git branch name

#+BEGIN_SRC emacs-lisp
  (defun --powerline-git-branch (this-face next-face)
    (let* ((b --git-branch-name)
           (string (if (string-equal b "") "" (concat " ± " b " "))))
      (list
       (powerline-raw string this-face)
       (powerline-arrow-left this-face next-face))))
#+END_SRC

**** Evil state

#+BEGIN_SRC emacs-lisp
  (defun --powerline-evil-state (this-face next-face)
    (list
     (powerline-arrow-right '--powerline-face-normal this-face)
     (powerline-raw (concat " " (format-mode-line 'evil-mode-line-tag) " ") this-face)
     (powerline-arrow-right this-face next-face)))
#+END_SRC

**** Major mode

#+BEGIN_SRC emacs-lisp
  (defun --powerline-major-mode (this-face next-face)
    (list
     (powerline-major-mode this-face 'l)
     (powerline-raw " " this-face)
     (powerline-arrow-right this-face next-face)))
#+END_SRC

**** Cursor's line and column coordinates

#+BEGIN_SRC emacs-lisp
  (defun --powerline-cursor-position (this-face next-face)
    (list
     (powerline-raw " %l" this-face 'r)
     (powerline-raw "•" this-face)
     (powerline-raw " %c" this-face 'r)))
#+END_SRC

**** Scroll position (HUD)

#+BEGIN_SRC emacs-lisp
  (defun --powerline-scroll-position (this-face next-face)
    (list
     (powerline-hud this-face next-face 2)))
#+END_SRC

*** Faces

Define custom powerline faces for our light theme.

#+BEGIN_SRC emacs-lisp
  (defface --powerline-face-normal
    '((t (:inherit --background :foreground "#eeeeee"))) "")
  (defface --powerline-face-lightest
    '((t (:background "#eeeeee" :foreground "#444444"))) "")
  (defface --powerline-face-light
    '((t (:background "#cccccc" :foreground "#444444"))) "")
  (defface --powerline-face-dark
    '((t (:background "#888888" :inherit --powerline-face-normal))) "")
  (defface --powerline-face-darkest
    '((t (:background "#444444" :inherit --powerline-face-normal))) "")
  (defface --powerline-face-inactive
    '((t (:slant italic :background "#eeeeee" :foreground "#444444"))) "")
  (defface --powerline-face-red
    '((t (:background "#a52a2a" :inherit --powerline-face-normal))) "")
  (defface --powerline-face-green
    '((t (:background "#4e9a06" :inherit --powerline-face-normal))) "")
  (defface --powerline-face-blue
    '((t (:background "#0084c8" :inherit --powerline-face-normal))) "")
#+END_SRC

*** Initialize

#+BEGIN_SRC emacs-lisp
  (defun --configure-powerline ()
    (let* ((active (eq powerline-selected-window (selected-window)))
           (none '--powerline-face-normal)
           (lightest (if active '--powerline-face-lightest '--powerline-face-inactive))
           (light (if active '--powerline-face-light '--powerline-face-inactive))
           (dark (if active '--powerline-face-dark '--powerline-face-inactive))
           (darkest (if active '--powerline-face-darkest '--powerline-face-inactive))
           (buffer-color (if (and (buffer-file-name)
                                  (file-exists-p (buffer-file-name))
                                  (buffer-modified-p))
                             '--powerline-face-red darkest))
           (state-color (--powerline-get-evil-state-color evil-mode-line-tag active))

           (lhs (append
                 (--powerline-buffer-id buffer-color dark)
                 (--powerline-git-branch dark none)))
           (rhs (append
                 (--powerline-evil-state state-color dark)
                 (--powerline-major-mode dark lightest)
                 (--powerline-cursor-position lightest darkest)
                 (--powerline-scroll-position darkest lightest))))
      (concat
       (powerline-render lhs)
       ;; Divide by modeline shrink factor then add 2 for powerline-hud width.
       (powerline-fill 'powerline-normal (+ 2 (* (powerline-width rhs) 0.72)))
       (powerline-render rhs))))

  (use-package powerline
    :ensure t
    :init (setq-default mode-line-format '("%e" (:eval (--configure-powerline)))))
#+END_SRC

** Shrink modeline

Smaller ~mode-line-inactive~ face sometime doesn't stick when new frames are created so force it with a hook.

#+BEGIN_SRC emacs-lisp
  (defun --ensure-small-modeline (&optional frame)
    (set-face-attribute 'mode-line          nil :height 72 :box nil :weight 'semi-bold)
    (set-face-attribute 'mode-line-inactive nil :height 72 :box nil :weight 'semi-bold))
  (--ensure-small-modeline)
  (add-hook 'after-make-frame-functions '--ensure-small-modeline)
#+END_SRC

** Uniquify buffer with parts of directory name

#+BEGIN_SRC emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Set the frame title

If buffer is visiting a file display its full path (_~/path/to/file_) , otherwise display just the buffer name (_*scratch*_).

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '(" " (:eval
               (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
#+END_SRC

** Fonts

Set font, font size, and lineheight.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'initial-frame-alist '(font . "Source Code Pro for Powerline-10") t)
  (add-to-list 'default-frame-alist '(font . "Source Code Pro for Powerline-10") t)
  (setq-default line-spacing 0.15)
#+END_SRC

** Cursor
*** Stop blinking

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

*** Invert cursor color

Set the cursor's color to the foreground color of thing at point. From https://www.reddit.com/r/emacs/comments/4c5g4i/help_how_do_i_change_the_cursor_to_have_the_same/

#+BEGIN_SRC emacs-lisp
  (use-package eyedropper
    :ensure t
    :config
    (setq --cursor-invert-active t)
    (defun --invert-cursor-color ()
      (interactive)
      (if --cursor-invert-active
          (set-cursor-color (eyedrop-foreground-at-point))))
    (add-hook 'post-command-hook '--invert-cursor-color))
#+END_SRC
** Highlight matching pairs

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0.0)
#+END_SRC

** Show uncompleted key chords in echo area right away

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

** Deactivate bell

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore visible-bell nil)
#+END_SRC

** Startup and scratch messages

Get rid of the "For information about GNU Emacs and the GNU system, type C-h C-a." echo area message by redefining ~display-startup-echo-area-message~, which is more reliable and portable than ~(setq inhibit-startup-echo-area-message "YOUR-USER-NAME")~.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (defun display-startup-echo-area-message ()
    (message ""))
  (setq initial-scratch-message nil)
#+END_SRC
